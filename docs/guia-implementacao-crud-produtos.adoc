= Guia de Implementa√ß√£o: CRUD de Produtos
:doctype: article
:encoding: utf-8
:lang: pt-BR
:toc: left
:toclevels: 3
:numbered:
:source-highlighter: coderay
:icons: font

== Vis√£o Geral

Este documento apresenta um **passo a passo detalhado** para implementa√ß√£o de um CRUD completo de produtos, seguindo exatamente os mesmos padr√µes arquiteturais utilizados no m√≥dulo de usu√°rios existente.

[IMPORTANT]
====
Este guia √© **conceitual**. N√£o cont√©m c√≥digo espec√≠fico, mas sim os passos e conceitos necess√°rios para implementar cada componente seguindo Clean Architecture e Domain-Driven Design.
====

=== Objetivos do Guia

- ‚úÖ **Replicar padr√µes** existentes na aplica√ß√£o
- ‚úÖ **Aplicar conceitos** atrav√©s da pr√°tica
- ‚úÖ **Implementar Clean Architecture** e **DDD**
- ‚úÖ **Seguir Object Calisthenics** e **SOLID**
- ‚úÖ **Criar API REST** padronizada

=== Como Usar Este Guia

[TIP]
====
**Recomenda√ß√µes**:
1. **Leia cada fase completamente** antes de come√ßar a implementar
2. **Compare sempre com o m√≥dulo Users** existente como refer√™ncia
3. **Implemente passo a passo**, n√£o pule etapas
4. **Teste cada componente** antes de passar para o pr√≥ximo
5. **Pe√ßa ajuda** se algum conceito n√£o estiver claro
====

=== Campos do Produto

[cols="3,2,5"]
|===
|Campo |Tipo |Descri√ß√£o

|*Campos Espec√≠ficos*
|
|

|`name` 
|string 
|Nome do produto

|`price` 
|float 
|Pre√ßo do produto

|`category` 
|string 
|Categoria do produto

|*Campos Padr√£o*
|
|

|`id` 
|int 
|Identificador √∫nico

|`status` 
|string 
|Status: draft, active, inactive

|`created_at` 
|DateTime 
|Data de cria√ß√£o

|`updated_at` 
|DateTime 
|Data de atualiza√ß√£o
|===

== FASE 1: Planejamento e Estrutura

=== Passo 1.1: Definir Estrutura de Diret√≥rios

==== Domain Layer
Criar estrutura base para o dom√≠nio de produtos:

[NOTE]
====
A estrutura de diret√≥rios segue o padr√£o DDD (Domain-Driven Design). Cada pasta tem um prop√≥sito espec√≠fico na arquitetura.
====

```
src/Domain/Products/
‚îú‚îÄ‚îÄ Entities/
‚îÇ   ‚îú‚îÄ‚îÄ ProductEntityInterface.php
‚îÇ   ‚îî‚îÄ‚îÄ Impl/
‚îÇ       ‚îî‚îÄ‚îÄ ProductEntity.php
‚îú‚îÄ‚îÄ Services/
‚îÇ   ‚îú‚îÄ‚îÄ ProductServiceInterface.php
‚îÇ   ‚îî‚îÄ‚îÄ Impl/
‚îÇ       ‚îî‚îÄ‚îÄ ProductService.php
‚îú‚îÄ‚îÄ Repositories/
‚îÇ   ‚îú‚îÄ‚îÄ ProductRepositoryInterface.php
‚îÇ   ‚îî‚îÄ‚îÄ Impl/
‚îÇ       ‚îî‚îÄ‚îÄ ProductRepository.php
‚îú‚îÄ‚îÄ DTOs/
‚îÇ   ‚îî‚îÄ‚îÄ Impl/
‚îÇ       ‚îú‚îÄ‚îÄ CreateProductDataDTO.php
‚îÇ       ‚îî‚îÄ‚îÄ UpdateProductDataDTO.php
‚îú‚îÄ‚îÄ Commands/
‚îÇ   ‚îî‚îÄ‚îÄ Impl/
‚îÇ       ‚îú‚îÄ‚îÄ CreateProductCommand.php
‚îÇ       ‚îî‚îÄ‚îÄ UpdateProductCommand.php
‚îî‚îÄ‚îÄ Validators/
    ‚îú‚îÄ‚îÄ ProductDataValidatorInterface.php
    ‚îî‚îÄ‚îÄ Impl/
        ‚îî‚îÄ‚îÄ ProductDataValidator.php
```

==== Application Layer
Criar estrutura para a camada de aplica√ß√£o:

```
src/Application/Modules/Products/
‚îú‚îÄ‚îÄ Controllers/
‚îÇ   ‚îú‚îÄ‚îÄ ProductControllerInterface.php
‚îÇ   ‚îî‚îÄ‚îÄ Impl/
‚îÇ       ‚îî‚îÄ‚îÄ ProductController.php
‚îú‚îÄ‚îÄ Http/
‚îÇ   ‚îî‚îÄ‚îÄ Routing/
‚îÇ       ‚îî‚îÄ‚îÄ ProductsRouteProvider.php
‚îî‚îÄ‚îÄ Bootstrap/
    ‚îî‚îÄ‚îÄ Impl/
        ‚îú‚îÄ‚îÄ ProductsBootstrap.php
        ‚îú‚îÄ‚îÄ ProductServiceDefinition.php
        ‚îî‚îÄ‚îÄ ProductControllerDefinition.php
```

=== Passo 1.2: Identificar Depend√™ncias

==== Depend√™ncias Necess√°rias (Localiza√ß√£o)
- **AbstractRepository**: `src/Domain/Common/Repositories/Impl/AbstractRepository.php`
- **AbstractRepositoryInterface**: `src/Domain/Common/Repositories/AbstractRepositoryInterface.php`
- **AbstractService**: `src/Domain/Common/Services/Impl/AbstractService.php`
- **AbstractServiceInterface**: `src/Domain/Common/Services/AbstractServiceInterface.php`
- **AbstractBaseController**: `src/Application/Shared/Controllers/Impl/AbstractBaseController.php`
- **AbstractBootstrap**: `src/Application/Shared/Impl/AbstractBootstrap.php`
- **TimestampableBehavior**: `src/Domain/Common/Entities/Behaviors/Impl/TimestampableBehavior.php`
- **Doctrine ORM**: Para persist√™ncia de dados

[TIP]
====
**Refer√™ncias**: Antes de implementar qualquer classe, sempre **examine as refer√™ncias existentes**:

1. **UserEntity** ‚Üí `src/Domain/Security/Entities/Impl/UserEntity.php`
2. **UserRepository** ‚Üí `src/Domain/Security/Repositories/Impl/UserRepository.php`
3. **UserService** ‚Üí `src/Domain/Security/Services/Impl/UserService.php`
4. **UserController** ‚Üí `src/Application/Modules/Security/Controllers/Impl/UserController.php`

Use estes arquivos como **template** para entender a estrutura!
====

==== Interfaces a Implementar
- ProductEntityInterface
- ProductServiceInterface  
- ProductRepositoryInterface
- ProductControllerInterface
- ProductDataValidatorInterface

==== Comando Para Examinar Estrutura de Refer√™ncia
```bash
# Ver estrutura do m√≥dulo Users (refer√™ncia)
tree src/Domain/Security/
tree src/Application/Modules/Security/

# Ver exemplo de Repository
cat src/Domain/Security/Repositories/Impl/UserRepository.php
```

== FASE 2: Camada de Dom√≠nio (Domain)

=== Passo 2.1: Criar ProductEntity

==== 2.1.1: Definir Interface
Criar interface com m√©todos principais da entidade:

**M√©todos obrigat√≥rios:**
- Getters b√°sicos (compatibilidade com ORM)
- M√©todos comportamentais (Tell Don't Ask)
- M√©todos de valida√ß√£o de regras de neg√≥cio
- Serializa√ß√£o JSON

==== 2.1.2: Implementar Classe ProductEntity
**Caracter√≠sticas da implementa√ß√£o:**

[cols="3,7"]
|===
|Aspecto |Implementa√ß√£o

|*Propriedades* 
|P√∫blicas (Object Calisthenics), tipadas explicitamente

|*Construtor* 
|Recebe apenas campos obrigat√≥rios, inicializa comportamentos

|*Behaviors* 
|Composi√ß√£o com TimestampableBehavior (se necess√°rio)

|*M√©todos Comportamentais* 
|activate(), deactivate(), updatePrice(), isActive(), canBeSold()

|*Valida√ß√µes* 
|Regras de neg√≥cio internas (pre√ßo > 0, categoria v√°lida)

|*Serializa√ß√£o* 
|JsonSerializable para API responses
|===

**M√©todos comportamentais sugeridos:**

[TIP]
====
**Tell Don't Ask**: A entidade deve ter comportamentos (m√©todos que fazem algo) ao inv√©s de apenas getters/setters. O cliente "pede para fazer" ao inv√©s de "perguntar e decidir".
====

- `activate()` - Ativa o produto para venda
- `deactivate()` - Desativa o produto (n√£o pode ser vendido)  
- `updatePrice()` - Atualiza pre√ßo com valida√ß√£o autom√°tica
- `isActive()` - Verifica se o produto est√° ativo
- `canBeSold()` - Verifica se pode ser vendido (ativo + estoque)
- `isPriceValid()` - Valida se o pre√ßo √© positivo
- `belongsToCategory()` - Verifica se pertence a uma categoria

=== Passo 2.2: Criar ProductRepository

[NOTE]
====
**Repository Pattern**: O reposit√≥rio abstrai o acesso aos dados. O service n√£o precisa saber se os dados v√™m do banco, arquivo, API, etc. O reposit√≥rio "esconde" essa complexidade.
====

[IMPORTANT]
====
**Refer√™ncia**: **SEMPRE examine primeiro o UserRepository** para entender como implementar:

```bash
# Ver a interface do UserRepository
cat src/Domain/Security/Repositories/UserRepositoryInterface.php

# Ver a implementa√ß√£o do UserRepository  
cat src/Domain/Security/Repositories/Impl/UserRepository.php
```

**Pontos-chave a observar:**
1. Como a interface estende `AbstractRepositoryInterface`
2. Como a implementa√ß√£o estende `AbstractRepository`
3. O m√©todo `getEntityClass()` - **obrigat√≥rio!**
4. Imports necess√°rios no topo do arquivo
5. Namespace correto
====

==== 2.2.1: Definir Interface
M√©todos espec√≠ficos para produtos al√©m dos padr√£o (CRUD b√°sico):

- `findByCategory()` - Buscar produtos por categoria
- `findActiveProducts()` - Buscar apenas produtos ativos
- `findByPriceRange()` - Buscar produtos em faixa de pre√ßo
- `searchByName()` - Buscar produtos por nome

**Template da Interface:**
```php
<?php

declare(strict_types=1);

namespace App\Domain\Products\Repositories;

use App\Domain\Common\Repositories\AbstractRepositoryInterface;
use App\Domain\Products\Entities\ProductEntityInterface;

interface ProductRepositoryInterface extends AbstractRepositoryInterface
{
    public function findByCategory(string $category): array;
    // ... outros m√©todos
}
```

==== 2.2.2: Implementar Repository
**Heran√ßa:** O reposit√≥rio vai estender o reposit√≥rio base existente

**Imports obrigat√≥rios:**
```php
use App\Domain\Common\Repositories\Impl\AbstractRepository;
use App\Domain\Products\Entities\Impl\ProductEntity;
use App\Domain\Products\Repositories\ProductRepositoryInterface;
use Doctrine\ORM\EntityManagerInterface;
```

**M√©todo obrigat√≥rio:**
```php
protected function getEntityClass(): string
{
    return ProductEntity::class;
}
```

**O que precisa implementar:**
- Construtor que chama `parent::__construct($entityManager)`
- Definir qual entidade este reposit√≥rio gerencia (ProductEntity)
- Criar m√©todos espec√≠ficos para consultas de produtos
- Implementar filtros e buscas personalizadas usando `$this->findBy()` ou `$this->createQueryBuilder()`

=== Passo 2.3: Criar DTOs

==== 2.3.1: CreateProductDataDTO
**Finalidade:** Transferir dados para cria√ß√£o de produto

**Propriedades obrigat√≥rias:**
- `name` (string) - Nome do produto
- `price` (decimal) - Pre√ßo do produto
- `category` (string) - Categoria do produto

**M√©todos necess√°rios:**
- Construtor que recebe todos os campos obrigat√≥rios
- M√©todo para criar DTO a partir de array de dados
- Valida√ß√£o b√°sica dos tipos de dados

==== 2.3.2: UpdateProductDataDTO
**Finalidade:** Transferir dados para atualiza√ß√£o

**Propriedades opcionais (podem ser nulas):**
- `name` - Novo nome (opcional)
- `price` - Novo pre√ßo (opcional)
- `category` - Nova categoria (opcional)
- `status` - Novo status (opcional)

**M√©todos necess√°rios:**
- Construtor que aceita todos os campos como opcionais
- M√©todo para criar DTO a partir de array de dados
- M√©todo para converter DTO de volta para array (apenas campos preenchidos)

=== Passo 2.4: Criar Commands

==== 2.4.1: CreateProductCommand
**Padr√£o Command:** Encapsula a opera√ß√£o de criar produto

**O que deve conter:**
- Guardar os dados do produto a ser criado (via DTO)
- Construtor que recebe os dados
- M√©todo para executar a cria√ß√£o usando o ProductService
- M√©todo para criar comando a partir de array de dados

==== 2.4.2: UpdateProductCommand  
**Similar ao comando de cria√ß√£o, mas para atualiza√ß√£o:**
- Guardar os dados de atualiza√ß√£o (via DTO)
- M√©todo para executar a atualiza√ß√£o usando ProductService e ID do produto

=== Passo 2.5: Criar ProductService

==== 2.5.1: Definir Interface
**Casos de uso principais:**

- `createProduct()` - Criar um novo produto
- `updateProduct()` - Atualizar produto existente por ID
- `deleteProduct()` - Deletar produto por ID
- `getAllProducts()` - Buscar todos os produtos
- `getProductById()` - Buscar produto espec√≠fico por ID
- `getProductsByCategory()` - Buscar produtos por categoria
- `activateProduct()` - Ativar produto por ID
- `deactivateProduct()` - Desativar produto por ID

==== 2.5.2: Implementar Service
**Heran√ßa:** O service vai estender o service base (se houver)

**Depend√™ncias necess√°rias:**
- ProductRepository (para acessar dados)
- Validator (para validar dados de entrada)

**Implementa√ß√µes principais:**

[cols="3,7"]
|===
|M√©todo |Responsabilidade

|`createProduct()` 
|Validar dados, criar entidade, persistir via repository

|`updateProduct()` 
|Buscar entidade, aplicar mudan√ßas (Tell Don't Ask), persistir

|`deleteProduct()` 
|Buscar entidade, remover via repository

|`getAllProducts()` 
|Delegar para repository->findAll()

|`getProductById()` 
|Delegar para repository->find()

|`activateProduct()` 
|Buscar entidade, chamar activate(), persistir

|M√©todos privados
|validatePrice(), validateCategory(), validateProductExists()
|===

=== Passo 2.6: Criar Validators (Opcional)

==== ProductDataValidator
**Responsabilidade:** Validar dados de entrada para produtos

**M√©todos:**
- `validateCreateProductData(array $data): ValidationResult`
- `validateUpdateProductData(array $data): ValidationResult`

**Valida√ß√µes implementadas:**
- Nome: obrigat√≥rio, m√≠nimo 2 caracteres
- Pre√ßo: obrigat√≥rio, maior que zero
- Categoria: obrigat√≥ria, valores v√°lidos
- Status: valores v√°lidos (draft, active, inactive)

== FASE 3: Camada de Aplica√ß√£o (Application)

=== Passo 3.1: Criar ProductController

==== 3.1.1: Definir Interface
**M√©todos obrigat√≥rios (padr√£o REST):**

- `create()` - Processar requisi√ß√£o POST para criar produto
- `index()` - Processar requisi√ß√£o GET para listar produtos  
- `show()` - Processar requisi√ß√£o GET para mostrar produto espec√≠fico
- `update()` - Processar requisi√ß√£o PUT para atualizar produto
- `delete()` - Processar requisi√ß√£o DELETE para remover produto

==== 3.1.2: Implementar Controller
**Heran√ßa:** O controller vai estender o controller base existente

**Depend√™ncias necess√°rias:**
- ProductService (para executar opera√ß√µes de neg√≥cio)

**Implementa√ß√£o de cada m√©todo:**

[cols="2,8"]
|===
|M√©todo |Fluxo de Implementa√ß√£o

|`create()` 
|1. Extrair dados JSON da requisi√ß√£o
2. Criar DTO com os dados recebidos
3. Chamar ProductService para criar produto
4. Tratar erros (valida√ß√£o ‚Üí 422, outros ‚Üí 500)
5. Retornar resposta padronizada (201 para sucesso)

|`index()` 
|1. Chamar ProductService para buscar todos os produtos
2. Retornar lista em resposta padronizada (200)

|`show()` 
|1. Extrair ID dos `$args`
2. Chamar ProductService para buscar produto por ID
3. Verificar se encontrou (404 se n√£o encontrou)
4. Retornar produto em resposta padronizada (200)

|`update()` 
|1. Extrair ID dos `$args`
2. Extrair dados JSON da requisi√ß√£o
3. Criar UpdateDTO
4. Chamar ProductService para atualizar produto
5. Tratar erros (404, 422, 500)
6. Retornar produto atualizado (200)

|`delete()` 
|1. Extrair ID dos `$args`
2. Chamar ProductService para deletar produto
3. Verificar se deletou (404 se n√£o encontrou)
4. Retornar resposta vazia de sucesso (200)
|===

**Padr√£o de tratamento de erros:**
- Erros de valida√ß√£o ‚Üí HTTP 422 + detalhes dos erros
- Erros de regra de neg√≥cio ‚Üí HTTP 404/409 + mensagem
- Erros gerais ‚Üí HTTP 500 + mensagem gen√©rica

=== Passo 3.2: Criar ProductsRouteProvider

==== 3.2.1: Implementar Interface RouteProviderInterface

**Configura√ß√µes obrigat√≥rias:**

- Prefixo das rotas: "/api/products"
- Nome do m√≥dulo: "Products"
- Prioridade de carregamento: 40 (ap√≥s System=30)
- Verifica√ß√£o de pertencimento ao m√≥dulo
- Defini√ß√£o de prioridade sobre outros providers

==== 3.2.2: Registrar Rotas REST

**Grupo de rotas:** `/api/products`

[cols="2,3,3,4"]
|===
|M√©todo HTTP |Rota |Controller |Descri√ß√£o

|GET 
|`/api/products` 
|`index()` 
|Listar todos os produtos

|GET 
|`/api/products/{id:[0-9]+}` 
|`show()` 
|Buscar produto por ID

|POST 
|`/api/products` 
|`create()` 
|Criar novo produto

|PUT 
|`/api/products/{id:[0-9]+}` 
|`update()` 
|Atualizar produto existente

|DELETE 
|`/api/products/{id:[0-9]+}` 
|`delete()` 
|Deletar produto
|===

**Rotas adicionais (opcionais):**

```
GET /api/products/category/{category}    - Produtos por categoria
POST /api/products/{id}/activate         - Ativar produto
POST /api/products/{id}/deactivate       - Desativar produto
```

=== Passo 3.3: Criar Bootstrap e Service Definitions

==== 3.3.1: ProductsBootstrap
**Heran√ßa:** Estender `AbstractBootstrap`

**Configura√ß√µes:**
- `getModuleName()`: "Products"
- `getPriority()`: 40
- `belongsToModule()`: true para "Products"
- `hasRoutes()`: true
- `getRouteProvider()`: inst√¢ncia de ProductsRouteProvider

**Service Definitions carregadas:**
- ProductServiceDefinition
- ProductControllerDefinition

==== 3.3.2: ProductServiceDefinition
**Registros necess√°rios no container DI:**

```
ProductRepositoryInterface::class => ProductRepository
ProductServiceInterface::class => ProductService  
ProductDataValidatorInterface::class => ProductDataValidator
```

**Configura√ß√£o das depend√™ncias:**
- ProductRepository precisa de EntityManager
- ProductService precisa de Repository + Validator

==== 3.3.3: ProductControllerDefinition  
**Registros necess√°rios:**

```
ProductControllerInterface::class => ProductController
```

**Depend√™ncias do Controller:**
- ProductServiceInterface (injetado automaticamente)

== FASE 4: Configura√ß√£o e Integra√ß√£o

=== Passo 4.1: Registrar Bootstrap

==== 4.1.1: Localizar BootstrapOrchestrator
Encontrar onde os bootstraps s√£o inicializados:
- Arquivo: `BootstrapOrchestrator->initializeDefaultBootstraps()`
- Localiza√ß√£o t√≠pica: `src/Application/Shared/Orchestrator/Impl/`

==== 4.1.2: Adicionar ProductsBootstrap
**No m√©todo de inicializa√ß√£o dos bootstraps:**

Adicionar o ProductsBootstrap na lista, seguindo a ordem de prioridades:
- CommonBootstrap (prioridade 10)
- SecurityBootstrap (prioridade 20)  
- SystemBootstrap (prioridade 30)
- **ProductsBootstrap (prioridade 40)** ‚Üê NOVO
- AuthBootstrap (prioridade 50)

=== Passo 4.2: Configurar Roteamento

==== 4.2.1: Verificar Carregamento Autom√°tico
O sistema j√° carrega RouteProviders automaticamente atrav√©s do:
- BootstrapOrchestrator->loadAllRoutes()
- Cada Bootstrap retorna seu RouteProvider

==== 4.2.2: Confirmar Integra√ß√£o
Verificar se ProductsBootstrap est√° retornando ProductsRouteProvider corretamente no m√©todo `getRouteProvider()`

=== Passo 4.3: Atualizar Composer

==== 4.3.1: Verificar Autoload
Confirmar se o namespace est√° configurado corretamente no arquivo composer.json para que as novas classes sejam encontradas automaticamente.

==== 4.3.2: Regenerar Autoload
Executar comando do composer para regenerar o autoload se necess√°rio:
`composer dump-autoload`

== FASE 5: Banco de Dados

=== Passo 5.1: Criar Migration

==== 5.1.1: Estrutura da Tabela Products

[cols="3,2,2,3"]
|===
|Campo |Tipo |Restri√ß√µes |Descri√ß√£o

|`id` 
|INT 
|PRIMARY KEY, AUTO_INCREMENT 
|Identificador √∫nico

|`name` 
|VARCHAR(255) 
|NOT NULL 
|Nome do produto

|`price` 
|DECIMAL(10,2) 
|NOT NULL 
|Pre√ßo do produto

|`category` 
|VARCHAR(100) 
|NOT NULL 
|Categoria do produto

|`status` 
|VARCHAR(20) 
|DEFAULT 'draft' 
|Status do produto

|`created_at` 
|DATETIME 
|NOT NULL 
|Data de cria√ß√£o

|`updated_at` 
|DATETIME 
|NOT NULL 
|Data de atualiza√ß√£o
|===

==== 5.1.2: Criar Arquivo de Migration
**Localiza√ß√£o:** `src/Infrastructure/Common/Database/Migrations/2025/`

**Nome sugerido:** `Version20251024120000_CreateProductsTable.php`

**Conte√∫do da migration:**
- `up()`: CREATE TABLE com estrutura definida
- `down()`: DROP TABLE products

==== 5.1.3: Executar Migration
**Executar via linha de comando:**
Usar o comando de migration do Docker para aplicar as mudan√ßas no banco de dados

=== Passo 5.2: Configurar Doctrine

==== 5.2.1: Anota√ß√µes ORM na ProductEntity
**Configura√ß√µes necess√°rias:**

```
@Entity(repositoryClass="ProductRepository")
@Table(name="products")
```

**Anota√ß√µes por propriedade:**
- `@Id @GeneratedValue @Column(type="integer")` para id
- `@Column(type="string", length=255)` para name
- `@Column(type="decimal", precision=10, scale=2)` para price
- `@Column(type="string", length=100)` para category
- `@Column(type="string", length=20)` para status
- `@Column(type="datetime")` para created_at/updated_at

==== 5.2.2: Verificar Mapeamento
**Validar configura√ß√£o:**
Usar comando do Doctrine para verificar se o mapeamento est√° correto

== FASE 6: Testes e Valida√ß√£o

=== Passo 6.1: Testes Manuais

==== 6.1.1: Testar Cria√ß√£o (POST)
**Endpoint:** `POST /api/products`

**Request de teste:**
```
Content-Type: application/json

{
  "name": "Smartphone XYZ",
  "price": 899.99,
  "category": "electronics"
}
```

**Response esperado:**
- Status: 201 Created
- Body: JSON com produto criado + message + timestamp

==== 6.1.2: Testar Listagem (GET)
**Endpoint:** `GET /api/products`

**Response esperado:**
- Status: 200 OK
- Body: Array de produtos com pagina√ß√£o (se implementada)

==== 6.1.3: Testar Busca por ID (GET)
**Endpoint:** `GET /api/products/1`

**Cen√°rios de teste:**
- ID existente: retorna produto (200)
- ID inexistente: retorna erro (404)

==== 6.1.4: Testar Atualiza√ß√£o (PUT)
**Endpoint:** `PUT /api/products/1`

**Request de teste:**
```json
{
  "name": "Smartphone XYZ Pro",
  "price": 1099.99,
  "status": "active"
}
```

==== 6.1.5: Testar Exclus√£o (DELETE)
**Endpoint:** `DELETE /api/products/1`

**Response esperado:**
- Status: 200 OK (se deletou)
- Status: 404 Not Found (se n√£o encontrou)

=== Passo 6.2: Testes de Valida√ß√£o

==== 6.2.1: Cen√°rios de Erro - Cria√ß√£o
**Testes obrigat√≥rios:**

[cols="4,3,3"]
|===
|Cen√°rio |Request |Response Esperado

|Nome vazio 
|`{"name": "", "price": 100, "category": "test"}` 
|422 + erro de valida√ß√£o

|Pre√ßo zero 
|`{"name": "Test", "price": 0, "category": "test"}` 
|422 + erro de valida√ß√£o

|Categoria vazia 
|`{"name": "Test", "price": 100, "category": ""}` 
|422 + erro de valida√ß√£o

|JSON malformado 
|`{"name": "Test"` 
|400 + erro de parsing

|Content-Type incorreto 
|text/plain 
|415 + erro de content-type
|===

==== 6.2.2: Cen√°rios de Erro - Busca/Atualiza√ß√£o
- ID n√£o num√©rico: deve retornar 404 (rota n√£o encontrada)
- ID inexistente: deve retornar 404 com mensagem adequada
- Dados inv√°lidos na atualiza√ß√£o: deve retornar 422

==== 6.2.3: Verificar Formato das Respostas
**Padr√£o esperado para sucesso:**
```json
{
  "success": true,
  "data": { /* dados do produto */ },
  "message": "Opera√ß√£o realizada com sucesso",
  "code": 200,
  "timestamp": "2025-09-24 15:30:45"
}
```

**Padr√£o esperado para erro:**
```json
{
  "success": false,
  "data": null,
  "message": "Erro na opera√ß√£o",
  "code": 422,
  "timestamp": "2025-09-24 15:30:45"
}
```

=== Passo 6.3: Testes de Integra√ß√£o

==== 6.3.1: Verificar Persist√™ncia
1. Criar produto via API
2. Verificar se foi salvo no banco de dados
3. Buscar produto via API
4. Confirmar dados consistentes

==== 6.3.2: Testar Comportamentos da Entidade
**Testes diretos nos m√©todos:**
- `activate()`: muda status para 'active'
- `deactivate()`: muda status para 'inactive'
- `updatePrice()`: atualiza pre√ßo e updated_at
- `isActive()`: retorna boolean correto
- `canBeSold()`: valida regras de neg√≥cio

==== 6.3.3: Validar Regras de Neg√≥cio
- Produto s√≥ pode ser vendido se ativo
- Pre√ßo deve ser sempre positivo
- Nome n√£o pode ser vazio
- Status deve ter valores v√°lidos

== FASE 7: Documenta√ß√£o

=== Passo 7.1: Documentar Endpoints

==== 7.1.1: Documenta√ß√£o da API
**Criar se√ß√£o no README ou documento espec√≠fico:**

**Endpoints Dispon√≠veis:**

[cols="2,3,5"]
|===
|M√©todo |Endpoint |Descri√ß√£o

|GET 
|`/api/products` 
|Lista todos os produtos

|GET 
|`/api/products/{id}` 
|Busca produto por ID

|POST 
|`/api/products` 
|Cria novo produto

|PUT 
|`/api/products/{id}` 
|Atualiza produto existente

|DELETE 
|`/api/products/{id}` 
|Remove produto
|===

==== 7.1.2: Exemplos de Request/Response
**Para cada endpoint, documentar:**
- Par√¢metros necess√°rios
- Exemplo de request (JSON)
- Exemplo de response de sucesso
- Exemplos de responses de erro

==== 7.1.3: C√≥digos de Status
**Documentar todos os c√≥digos retornados:**

[cols="2,8"]
|===
|Status |Significado

|200 
|Opera√ß√£o realizada com sucesso

|201 
|Recurso criado com sucesso

|400 
|Erro na requisi√ß√£o (JSON malformado)

|404 
|Recurso n√£o encontrado

|422 
|Dados inv√°lidos (erro de valida√ß√£o)

|500 
|Erro interno do servidor
|===

=== Passo 7.2: Atualizar README

==== 7.2.1: Adicionar Se√ß√£o Products
**Incluir no README principal:**
- Descri√ß√£o do m√≥dulo Products
- Lista de funcionalidades implementadas
- Links para documenta√ß√£o detalhada da API

==== 7.2.2: Exemplos de Uso
**Incluir exemplos pr√°ticos:**
- Como criar um produto via curl
- Como buscar produtos via Postman
- Como integrar com outros m√≥dulos

== CHECKLIST FINAL

=== Domain Layer
- [ ] ProductEntityInterface definida
- [ ] ProductEntity implementada com comportamentos
- [ ] ProductServiceInterface definida
- [ ] ProductService implementado com casos de uso
- [ ] ProductRepositoryInterface definida
- [ ] ProductRepository implementado
- [ ] CreateProductDataDTO criado
- [ ] UpdateProductDataDTO criado
- [ ] CreateProductCommand implementado
- [ ] UpdateProductCommand implementado
- [ ] ProductDataValidator implementado

=== Application Layer
- [ ] ProductControllerInterface definida
- [ ] ProductController implementado com CRUD
- [ ] ProductsRouteProvider implementado
- [ ] ProductsBootstrap criado
- [ ] ProductServiceDefinition configurada
- [ ] ProductControllerDefinition configurada

=== Infrastructure
- [ ] Migration criada e executada
- [ ] Doctrine configurado na entidade
- [ ] Mapeamento ORM validado

=== Integration
- [ ] Bootstrap registrado no Orchestrator
- [ ] Rotas carregadas automaticamente
- [ ] Container DI configurado

=== Testing
- [ ] Teste POST /api/products (criar)
- [ ] Teste GET /api/products (listar)
- [ ] Teste GET /api/products/{id} (buscar)
- [ ] Teste PUT /api/products/{id} (atualizar)
- [ ] Teste DELETE /api/products/{id} (deletar)
- [ ] Testes de valida√ß√£o (422)
- [ ] Testes de erro (404, 500)
- [ ] Verifica√ß√£o de persist√™ncia no banco

=== Documentation
- [ ] Endpoints documentados
- [ ] Exemplos de request/response
- [ ] README atualizado
- [ ] C√≥digos de status documentados

== Testes da Implementa√ß√£o

Ap√≥s implementa√ß√£o completa, executar os testes para validar funcionamento.

=== Prepara√ß√£o para Testes

**1. Verificar se o servidor est√° rodando:**
```bash
curl -X GET "http://localhost:8080/health" -H "Content-Type: application/json"
```
*Deve retornar status 200 com informa√ß√µes do sistema*

**2. Confirmar que a migration foi executada:**
- Verificar se a tabela `products` existe no banco
- Confirmar se possui todas as colunas necess√°rias

=== Testes dos Endpoints CRUD

**IMPORTANTE:** Todos os testes devem ser feitos com o cabe√ßalho `Content-Type: application/json`

==== 1. Testar Listagem (GET /api/products)
```bash
curl -X GET "http://localhost:8080/api/products" -H "Content-Type: application/json" -s
```

*Resultado esperado:*
- **Status Code:** 200
- **JSON Response:** Array de produtos (pode estar vazio inicialmente)
- **Estrutura:** `{"success": true, "data": [...], "message": "...", "code": 200}`

==== 2. Testar Cria√ß√£o (POST /api/products)
```bash
curl -X POST "http://localhost:8080/api/products" \
     -H "Content-Type: application/json" \
     -d '{"name":"Produto Teste","price":29.90,"category":"Eletr√¥nicos","status":"active"}' -s
```

*Resultado esperado:*
- **Status Code:** 201
- **JSON Response:** Produto criado com todos os campos
- **Campos retornados:** id, uuid, name, price, category, status, createdAt, updatedAt

==== 3. Testar Busca por ID (GET /api/products/{id})
```bash
# Usar o ID retornado na cria√ß√£o
curl -X GET "http://localhost:8080/api/products/1" -H "Content-Type: application/json" -s
```

*Resultado esperado:*
- **Status Code:** 200 (se existe) ou 404 (se n√£o existe)
- **JSON Response:** Dados completos do produto

==== 4. Testar Atualiza√ß√£o (PUT /api/products/{id})
```bash
curl -X PUT "http://localhost:8080/api/products/1" \
     -H "Content-Type: application/json" \
     -d '{"name":"Produto Atualizado","price":39.90}' -s
```

*Resultado esperado:*
- **Status Code:** 200
- **JSON Response:** Produto com dados atualizados
- **Verifica√ß√£o:** `updatedAt` deve ser diferente de `createdAt`

==== 5. Testar Exclus√£o (DELETE /api/products/{id})
```bash
curl -X DELETE "http://localhost:8080/api/products/1" -H "Content-Type: application/json" -s
```

*Resultado esperado:*
- **Status Code:** 204 ou 200
- **JSON Response:** Mensagem de confirma√ß√£o

=== Testes de Valida√ß√£o

**1. Teste com dados inv√°lidos (deve retornar 422):**
```bash
curl -X POST "http://localhost:8080/api/products" \
     -H "Content-Type: application/json" \
     -d '{"name":"","price":-10,"category":""}' -s
```

**2. Teste sem Content-Type (deve retornar 400):**
```bash
curl -X POST "http://localhost:8080/api/products" -d '{"name":"teste"}' -s
```

**3. Teste de produto inexistente (deve retornar 404):**
```bash
curl -X GET "http://localhost:8080/api/products/99999" -H "Content-Type: application/json" -s
```

=== Verifica√ß√£o de JSON V√°lido

Verifica√ß√£o de JSON v√°lido:
```bash
# Linux/Mac com python
curl -X GET "http://localhost:8080/api/products" -H "Content-Type: application/json" -s | python3 -c "
import sys, json
try:
    data = json.loads(sys.stdin.read())
    print('‚úÖ JSON v√°lido!')
    print(json.dumps(data, indent=2))
except Exception as e:
    print('‚ùå JSON inv√°lido:', str(e))
"
```

=== Checklist de Testes Completos

Ap√≥s implementa√ß√£o, verificar:

- [ ] ‚úÖ GET /api/products retorna 200 e array v√°lido
- [ ] ‚úÖ POST /api/products com dados v√°lidos retorna 201
- [ ] ‚úÖ POST /api/products com dados inv√°lidos retorna 422
- [ ] ‚úÖ GET /api/products/{id} existente retorna 200
- [ ] ‚úÖ GET /api/products/{id} inexistente retorna 404  
- [ ] ‚úÖ PUT /api/products/{id} com dados v√°lidos retorna 200
- [ ] ‚úÖ DELETE /api/products/{id} retorna 204
- [ ] ‚úÖ Todas as respostas s√£o JSON v√°lidos
- [ ] ‚úÖ Dados persistem corretamente no banco
- [ ] ‚úÖ Valida√ß√µes funcionam conforme regras
- [ ] ‚úÖ Timestamps s√£o atualizados corretamente

=== Solu√ß√£o de Problemas Comuns

**1. Erro 500 - "Class not found":**
- Verificar se todas as classes foram criadas
- Confirmar se o Bootstrap foi registrado no `BootstrapOrchestrator`
- Verificar namespaces e imports

**2. Erro 404 - "Not found":**
- Confirmar se as rotas foram registradas
- Verificar se `ProductsRouteProvider` est√° funcionando
- Testar outros endpoints para confirmar que o servidor est√° funcionando

**3. JSON inv√°lido ou duplicado:**
- Verificar se o middleware UTF-8 n√£o est√° duplicando conte√∫do
- Confirmar se os controllers retornam JSON v√°lido

**4. Erro de valida√ß√£o inesperado:**
- Verificar se `ProductDataValidator` est√° implementado corretamente
- Confirmar regras de valida√ß√£o nos DTOs

== Resultado Final

Ap√≥s implementa√ß√£o completa:

‚úÖ **CRUD completo** de produtos funcionando  
‚úÖ **API REST** com 5 endpoints padronizados  
‚úÖ **Domain-Driven Design** implementado  
‚úÖ **Clean Architecture** seguida  
‚úÖ **SOLID e Object Calisthenics** aplicados  
‚úÖ **Tratamento de erros** padronizado  
‚úÖ **Documenta√ß√£o** completa da API  

O m√≥dulo de produtos ser√° uma **r√©plica fiel** do m√≥dulo de usu√°rios, aplicando os mesmos padr√µes arquiteturais! üöÄ

---

*Documento criado em 24/09/2025 - Vers√£o 1.0*
